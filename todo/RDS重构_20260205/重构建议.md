### 第一部分：数据库结构重构计划

目前的结构是“以对象为中心”，我们需要转向“以网络为中心”。

#### 1. 新增表结构 (Schema)

你需要创建两张核心表来承载网状关系。请在数据库中执行以下 SQL：

```sql
-- 1. 节点表：存储所有“点”（包括物理设备、逻辑功能组、安装位置）
CREATE TABLE rds_nodes (
    id UUID PRIMARY KEY,                   -- 确定性UUID (基于 full_code 生成)
    object_id UUID REFERENCES rds_objects(id), -- 关联物理资产 (可为空，如果是纯逻辑节点)
    
    full_code VARCHAR(255) NOT NULL,       -- 完整编码 (如 ===DY1.AH1)
    code VARCHAR(50) NOT NULL,             -- 自身短码 (如 AH1)
    aspect VARCHAR(20) NOT NULL,           -- 'power' | 'function' | 'location'
    label VARCHAR(255),                    -- 显示名称
    level INTEGER,                         -- 层级深度 (方便前端渲染分层)
    
    created_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(full_code)                      -- 确保编码唯一性
);

-- 2. 边表：存储所有“线”（包括层级归属、供电关系、位置包含）
CREATE TABLE rds_edges (
    id UUID PRIMARY KEY,
    source_node_id UUID REFERENCES rds_nodes(id) ON DELETE CASCADE,
    target_node_id UUID REFERENCES rds_nodes(id) ON DELETE CASCADE,
    
    relation_type VARCHAR(50) NOT NULL,    
    -- 关键类型：
    -- 'hierarchy':  父子关系 (如 变压器 -> 馈线柜)
    -- 'powers':     供电关系 (如 馈线柜 -> 水泵)
    -- 'located_at': 位置关系 (如 房间 -> 设备)
    
    properties JSONB,                      -- 存储线的属性 (如电缆规格、回路编号)
    UNIQUE(source_node_id, target_node_id, relation_type)
);

```

---

### 第二部分：Python 重构/迁移算法

这是一个“生成器脚本”，它读取你的 Excel/CSV 数据，解析其中的树状和网状逻辑，并生成标准的 SQL `INSERT` 语句。

你可以直接运行此脚本，生成 `migrate_to_graph.sql` 文件，然后在数据库中执行该 SQL 文件即可完成数据迁移。

#### Python 脚本 (复制保存为 `build_graph_sql.py`)

```python
import pandas as pd
import uuid

# 配置：输入文件和输出SQL文件
INPUT_CSV = 'MC数据20230620_NEW.xlsx - 数据导出模板.csv'
OUTPUT_SQL = 'migrate_to_graph.sql'

# 辅助：生成确定性 UUID (保证多次运行生成的 ID 一致)
def get_uuid(key_string):
    return str(uuid.uuid5(uuid.NAMESPACE_DNS, str(key_string)))

def escape_sql(text):
    if pd.isna(text): return ""
    return str(text).replace("'", "''")

def generate_sql():
    print(f"正在读取 {INPUT_CSV} ...")
    try:
        df = pd.read_csv(INPUT_CSV)
    except Exception as e:
        print(f"错误: {e}")
        return

    sql_lines = ["BEGIN;", "TRUNCATE rds_nodes, rds_edges CASCADE;"]
    
    # 缓存已处理的 ID 以去重
    seen_nodes = set()
    seen_edges = set()

    # 1. 先把物理设备入库 (rds_objects 逻辑，假设表已存在，这里只做关联准备)
    # 实际项目中，你可能需要先 Insert rds_objects。
    # 这里我们重点生成 rds_nodes 和 rds_edges。

    # 通用处理函数：解析层级列
    def process_hierarchy_column(row, col_name, aspect_type):
        raw_val = row.get(col_name)
        if pd.isna(raw_val) or str(raw_val).strip() == "":
            return

        full_str = str(raw_val).strip()
        
        # 识别前缀
        prefix = ""
        if full_str.startswith("==="): prefix = "==="
        elif full_str.startswith("++"): prefix = "++"
        elif full_str.startswith("="): prefix = "="
        elif full_str.startswith("+"): prefix = "+"
        
        # 拆分层级
        clean_code = full_str[len(prefix):]
        parts = [p for p in clean_code.split('.') if p]
        
        parent_uuid = None
        current_full_code = ""

        for i, part in enumerate(parts):
            # 1. 构建当前节点的 Code
            if i == 0: current_full_code = prefix + part
            else: current_full_code += "." + part
            
            node_uuid = get_uuid(f"NODE_{current_full_code}")
            
            # 2. 如果节点不存在，生成 Insert 语句
            if node_uuid not in seen_nodes:
                # 判断是否关联物理设备：只有当前列的“末端叶子节点”才关联行的设备
                # 且该行必须有设备编码
                obj_ref = "NULL"
                label = part
                if i == len(parts) - 1 and pd.notna(row.get('设备编码')):
                    # 这里假设 rds_objects 的 ID 也是基于设备编码生成的 UUID
                    dev_code = str(row['设备编码']).strip()
                    obj_uuid = get_uuid(f"OBJ_{dev_code}") 
                    obj_ref = f"'{obj_uuid}'"
                    if pd.notna(row.get('名称')):
                        label = f"{part} ({row['名称']})"

                sql = f"""
                INSERT INTO rds_nodes (id, object_id, full_code, code, aspect, label, level)
                VALUES ('{node_uuid}', {obj_ref}, '{current_full_code}', '{part}', '{aspect_type}', '{escape_sql(label)}', {i+1})
                ON CONFLICT (id) DO NOTHING;
                """
                sql_lines.append(sql.strip())
                seen_nodes.add(node_uuid)

            # 3. 生成层级边 (Hierarchy Edge)
            if parent_uuid:
                edge_uuid = get_uuid(f"EDGE_{parent_uuid}_{node_uuid}_hierarchy")
                if edge_uuid not in seen_edges:
                    sql = f"""
                    INSERT INTO rds_edges (id, source_node_id, target_node_id, relation_type)
                    VALUES ('{edge_uuid}', '{parent_uuid}', '{node_uuid}', 'hierarchy')
                    ON CONFLICT (id) DO NOTHING;
                    """
                    sql_lines.append(sql.strip())
                    seen_edges.add(edge_uuid)
            
            parent_uuid = node_uuid

    # 遍历每一行数据
    for _, row in df.iterrows():
        # 优先处理电源网络
        process_hierarchy_column(row, '电源功能', 'power')
        process_hierarchy_column(row, '工艺功能', 'function')
        process_hierarchy_column(row, '位置', 'location')

    sql_lines.append("COMMIT;")
    
    # 写入文件
    with open(OUTPUT_SQL, 'w', encoding='utf-8') as f:
        f.write("\n".join(sql_lines))
    
    print(f"✅ 生成完成！SQL文件已保存至: {OUTPUT_SQL}")
    print(f"   共生成 {len(sql_lines)} 条语句。")

if __name__ == "__main__":
    generate_sql()

```

---

### 第三部分：电源网络前端表达控件建议

对于“电源功能网络”（Power Function Network），其特点是：

1. **有向性 (Directed):** 电流有明确方向（源 -> 负载）。
2. **层次性 (Hierarchical):** 变电站 -> 母线 -> 馈线柜 -> 分电箱 -> 终端。
3. **拓扑复杂:** 可能存在环网或多路供电（Mesh）。

#### 推荐方案：AntV G6 (Graph Visualization)

[AntV G6](https://g6.antv.antgroup.com/) 是目前国内工程领域最适合的图可视化引擎。

* **推荐理由：**
* **Combo 机制 (分组):** G6 支持将节点“打包”进 Combo。非常适合表现配电柜（Parent）内部包含多个断路器（Children）的物理嵌套结构。
* **布局算法丰富:** 提供了 `Dagre`（层次布局，最适合电路图）和 `Mindmap`（脑图布局）。
* **性能强大:** Canvas/WebGL 渲染，轻松支撑数千个节点的电路图。
* **自定义节点:** 你可以把断路器画成电气符号（而不只是圆圈）。


* **推荐控件配置 (Config):**
* **布局 (Layout):** 使用 `dagre` 布局，设置 `rankdir: 'LR'` (从左到右流向)。
* **节点 (Node):** 定义 `Rect` 形状，根据 `rds_nodes.aspect` 字段给不同颜色（电源为红色系，设备为蓝色系）。
* **边 (Edge):** 使用 `polyline` (折线)，符合电气原理图的审美习惯。



#### 备选方案：React Flow

如果你的系统是基于 React 开发的，且你需要**极强的交互性**（比如用户可以拖拽连线来重新设计电路），那么 **React Flow** 是首选。

* **优点:** 完美的 React 组件封装，开发体验极好。
* **缺点:** 自动布局能力弱于 G6，通常需要引入第三方库（如 `dagrejs`）来计算节点位置。

**总结建议：**
如果侧重**展示和自动布局**（导入数据直接看图），用 **AntV G6**。
如果侧重**编辑器功能**（用户手动画图），用 **React Flow**。