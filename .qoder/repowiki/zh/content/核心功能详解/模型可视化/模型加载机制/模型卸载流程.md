# 模型卸载流程

<cite>
**本文档引用文件**   
- [MainView.vue](file://src/components/MainView.vue)
- [App.vue](file://src/App.vue)
</cite>

## 目录
1. [模型卸载流程概述](#模型卸载流程概述)
2. [获取可见模型列表](#获取可见模型列表)
3. [遍历并卸载模型](#遍历并卸载模型)
4. [异步延迟等待](#异步延迟等待)
5. [完整代码逻辑示例](#完整代码逻辑示例)
6. [边界情况处理](#边界情况处理)
7. [内存泄漏防护机制](#内存泄漏防护机制)

## 模型卸载流程概述

在加载新模型之前，系统必须安全地卸载当前已加载的模型，以防止内存泄漏和确保新模型能够正确加载。该流程通过`loadNewModel`函数实现，首先检查是否正在加载模型或目标模型是否已加载，然后执行模型卸载操作。整个过程包含获取可见模型列表、遍历卸载每个模型、引入异步延迟等待以及最终加载新模型等关键步骤。

**Section sources**
- [MainView.vue](file://src/components/MainView.vue#L600-L702)

## 获取可见模型列表

系统通过Viewer的`getVisibleModels`方法获取所有当前可见的模型。该方法是首选的模型获取方式，因为它能返回所有可见模型的数组。为了确保兼容性，代码实现了优雅降级机制：当`getVisibleModels`方法不可用时，会回退到使用`viewer.model`属性。这种双重检查机制保证了代码在不同Viewer版本下的兼容性。

```javascript
const modelsToUnload = viewer.getVisibleModels ? viewer.getVisibleModels() : (viewer.model ? [viewer.model] : []);
```

此实现确保了即使在较旧版本的Viewer中，也能正确获取到需要卸载的模型列表，从而提高了系统的健壮性和适应性。

**Section sources**
- [MainView.vue](file://src/components/MainView.vue#L653-L654)

## 遍历并卸载模型

获取模型列表后，系统会遍历该列表并逐个调用`unloadModel`方法来卸载每个模型。这一过程通过`forEach`循环实现，对每个模型实例执行卸载操作。在卸载过程中，系统会记录详细的日志信息，包括要卸载的模型总数和每个模型的卸载进度，这有助于调试和监控模型卸载的状态。

```javascript
if (modelsToUnload.length > 0) {
  console.log(`🗑️ 卸载 ${modelsToUnload.length} 个模型`);
  modelsToUnload.forEach((model, index) => {
    console.log(`  - 卸载模型 ${index + 1}`);
    viewer.unloadModel(model);
  });
}
```

当模型列表为空时，系统会输出"没有需要卸载的模型"的日志信息，表明当前无需执行卸载操作。这种条件判断避免了不必要的处理，提高了执行效率。

**Section sources**
- [MainView.vue](file://src/components/MainView.vue#L655-L665)

## 异步延迟等待

在卸载所有模型后，系统会引入一个短暂的异步延迟（100毫秒），以确保Viewer内部状态完全清理。这个延迟通过`Promise`和`setTimeout`实现：

```javascript
await new Promise(resolve => setTimeout(resolve, 100));
```

此延迟等待是确保系统稳定性的关键步骤。它允许Viewer有足够的时间完成内部资源的释放和状态重置，防止因状态冲突导致的新模型加载失败。虽然100毫秒是一个相对较短的时间，但它足以让Viewer完成大部分内部清理工作，同时不会对用户体验造成明显影响。

**Section sources**
- [MainView.vue](file://src/components/MainView.vue#L662-L663)

## 完整代码逻辑示例

以下是模型卸载和加载的完整逻辑代码示例，展示了从卸载旧模型到加载新模型的完整流程：

```javascript
// 卸载所有当前加载的模型
console.log('🧹 开始卸载旧模型...');
const modelsToUnload = viewer.getVisibleModels ? viewer.getVisibleModels() : (viewer.model ? [viewer.model] : []);

if (modelsToUnload.length > 0) {
  console.log(`🗑️ 卸载 ${modelsToUnload.length} 个模型`);
  modelsToUnload.forEach((model, index) => {
    console.log(`  - 卸载模型 ${index + 1}`);
    viewer.unloadModel(model);
  });
  // 等待卸载完成
  await new Promise(resolve => setTimeout(resolve, 100));
} else {
  console.log('ℹ️ 没有需要卸载的模型');
}

// 加载新模型
viewer.loadModel(finalPath, {}, (model) => {
  console.log('✅ 新模型加载成功:', finalPath);
  // 其他初始化设置...
}, (errorCode) => {
  console.error('❌ 模型加载失败:', errorCode, finalPath);
});
```

**Section sources**
- [MainView.vue](file://src/components/MainView.vue#L651-L702)

## 边界情况处理

系统对多种边界情况进行妥善处理，确保流程的鲁棒性。首先，通过检查`isLoadingModel`和`currentModelPath`来防止重复加载同一个模型，避免不必要的资源消耗。其次，当模型列表为空时，系统会跳过卸载过程并记录相应日志，而不是尝试执行无效操作。

此外，系统还实现了模型路径的预检机制，通过`HEAD`请求验证候选路径的有效性，避免Viewer因无效路径而弹出错误提示。这种预防性检查大大提高了用户体验，使系统能够优雅地处理各种异常情况。

**Section sources**
- [MainView.vue](file://src/components/MainView.vue#L604-L649)

## 内存泄漏防护机制

该模型卸载流程对防止内存泄漏和确保新模型正确加载起到了关键作用。通过彻底卸载旧模型，系统释放了大量内存资源，包括几何数据、纹理、材质和其他相关对象。这不仅防止了内存泄漏，还为新模型的加载创造了干净的环境。

卸载流程与Viewer的事件系统紧密集成，确保在模型完全卸载后才开始加载新模型。这种顺序执行保证了Viewer内部状态的一致性，避免了因状态冲突导致的渲染问题或崩溃。此外，通过重置各种状态变量（如`roomTags`、`foundRoomDbIds`等），系统确保了每次模型加载都是在一个干净的状态下进行的。

**Section sources**
- [MainView.vue](file://src/components/MainView.vue#L786-L795)
- [MainView.vue](file://src/components/MainView.vue#L651-L702)